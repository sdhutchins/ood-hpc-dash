{% extends "base.html" %}

{% block content %}
<div class="row mb-4">
    <div class="col">
        <br/>
        <h3>Modules</h3>
        <p class="text-muted">View available modules from the system using 'module -t spider'.</p>
    </div>
</div>

<div class="row mb-3">
    <div class="col-md-4">
        <label for="moduleSearch" class="form-label visually-hidden">Search modules</label>
        <input 
            type="text" 
            id="moduleSearch" 
            placeholder="Search modules..." 
            class="form-control"
            aria-label="Search modules by name or version"
        >
    </div>
    <div class="col-md-4">
        <label for="categoryFilter" class="form-label visually-hidden">Filter by category</label>
        <select id="categoryFilter" class="form-select" aria-label="Filter modules by category">
            <option value="">All Categories</option>
            {% if category_order %}
                {% for category in category_order %}
                    <option value="{{ category }}">{{ category }}</option>
                {% endfor %}
            {% endif %}
        </select>
    </div>
    <div class="col-md-4 d-flex align-items-center">
        <small class="text-muted">
            <strong id="uniqueCount" aria-live="polite">{{ unique_count or 0 }}</strong> unique software packages
        </small>
    </div>
</div>

<div class="row">
    <div class="col">
        <div id="loadingCard" class="card {% if modules and modules|length > 0 and not cache_empty %}d-none{% endif %}">
            <div class="card-body text-center py-5">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <p class="mt-3 text-muted" id="loadingMessage">Loading modules...</p>
            </div>
        </div>
        <div id="modulesCard" class="{% if not modules or modules|length == 0 %}d-none{% endif %}">
            <div class="card shadow-sm">
                <div class="card-header" style="background-color: var(--theme-bg-color);">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <div>
                            <h5 class="mb-0">Available Modules</h5>
                            {% if cache_timestamp %}
                            <small class="text-muted d-block" id="cacheTimestamp">
                                Last updated: <span id="cacheTimestampValue">{{ cache_timestamp|timestamp_to_datetime }}</span>
                            </small>
                            {% endif %}
                        </div>
                        <button type="button" class="btn btn-sm" id="refreshModulesBtn" style="background-color: var(--theme-bg-color); border-color: var(--theme-bg-color); color: var(--theme-text-color);" title="Refresh module list">
                            <i class="fas fa-sync-alt me-1"></i><span>Refresh</span>
                        </button>
                    </div>
                    <div id="progressBarContainer" class="d-none">
                        <div class="d-flex justify-content-between align-items-center mb-1">
                            <small class="text-muted" id="progressText">Loading modules...</small>
                            <small class="text-muted" id="progressCount">0/0</small>
                        </div>
                        <div class="progress" style="height: 8px;">
                            <div class="progress-bar progress-bar-striped progress-bar-animated" 
                                 role="progressbar" 
                                 id="progressBar"
                                 style="width: 0%"
                                 aria-valuenow="0" 
                                 aria-valuemin="0" 
                                 aria-valuemax="100">
                            </div>
                        </div>
                    </div>
                    <div id="descriptionsLoadingAlert" class="alert alert-info alert-dismissible fade show d-none mt-2 mb-0" role="alert">
                        <i class="fas fa-spinner fa-spin me-2"></i>
                        <span id="descriptionsLoadingText">Loading descriptions...</span>
                        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                    </div>
                    <div id="descriptionsCompleteAlert" class="alert alert-success alert-dismissible fade show d-none mt-2 mb-0" role="alert">
                        <i class="fas fa-check-circle me-2"></i>
                        <strong>Descriptions loaded!</strong> Please <a href="javascript:location.reload()" class="alert-link">reload the page</a> to see all module descriptions.
                        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                    </div>
                </div>
                <div class="card-body p-0">
                    <div class="table-responsive">
                        <table class="table table-hover table-sm mb-0">
                            <thead style="background-color: var(--theme-bg-color);">
                                <tr>
                                    <th scope="col">Module</th>
                                    <th scope="col">Description</th>
                                    <th scope="col">Versions</th>
                                </tr>
                            </thead>
                            <tbody id="modulesTableBody">
                                {% if modules %}
                                {% for module in modules %}
                                <tr class="module-row" data-category="{{ module.category }}">
                                    <td><code>{{ module.name }}</code></td>
                                    <td>
                                        {% if module.description %}
                                            <small class="text-muted">{{ module.description }}</small>
                                        {% else %}
                                            <span class="text-muted">-</span>
                                        {% endif %}
                                    </td>
                                    <td>
                                        {% if module.versions %}
                                            {% for version in module.versions %}
                                                <button type="button" class="btn btn-sm copy-version me-1 mb-1" data-version="{{ version }}" title="Click to copy: module load {{ version }}" style="background-color: var(--theme-bg-color); border-color: var(--theme-bg-color); color: var(--theme-text-color);">
                                                    <i class="fa-regular fa-copy me-1"></i><code class="text-reset">{{ version }}</code>
                                                </button>
                                            {% endfor %}
                                        {% else %}
                                            <span class="text-muted">-</span>
                                        {% endif %}
                                    </td>
                                </tr>
                                {% endfor %}
                                {% endif %}
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
(function() {
    'use strict';
    
    // Debounce function for performance
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }
    
    document.addEventListener('DOMContentLoaded', function() {
        const searchInput = document.getElementById('moduleSearch');
        const categoryFilter = document.getElementById('categoryFilter');
        let allModules = {% if modules %}{{ modules|tojson|safe }}{% else %}[]{% endif %};
        let categoryOrder = {% if category_order %}{{ category_order|tojson|safe }}{% else %}[]{% endif %};
        
        // Only start streaming if cache is truly empty
        {% if cache_empty %}
        // Start streaming modules if cache is empty
        (function() {
            function startStreamingModules() {
            // Show loading state
            document.getElementById('loadingCard').classList.remove('d-none');
            document.getElementById('modulesCard').classList.add('d-none');
            
            // Clear table
            const tbody = document.getElementById('modulesTableBody');
            if (tbody) {
                tbody.innerHTML = '';
            }
            allModules = [];
            
                // Show progress bar
                const progressBarContainer = document.getElementById('progressBarContainer');
                if (progressBarContainer) {
                    progressBarContainer.classList.remove('d-none');
                }
                const progressBar = document.getElementById('progressBar');
                if (progressBar) {
                    progressBar.style.width = '0%';
                    progressBar.setAttribute('aria-valuenow', 0);
                }
                
                // Start refresh process
                fetch('{{ url_for("modules.refresh_start") }}', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to start refresh');
                    }
                    
                    // Create EventSource for streaming (GET endpoint)
                    const eventSource = new EventSource('{{ url_for("modules.refresh_modules") }}');
                    
                    let moduleCount = 0;
                    const collectedModules = [];
                    
                    eventSource.onmessage = function(event) {
                        try {
                            const data = JSON.parse(event.data);
                            
                            if (data.type === 'progress') {
                                // Update progress bar
                                if (data.total && data.current !== undefined) {
                                    const percentage = Math.round((data.current / data.total) * 100);
                                    if (progressBar) {
                                        progressBar.style.width = percentage + '%';
                                        progressBar.setAttribute('aria-valuenow', percentage);
                                    }
                                    const progressCount = document.getElementById('progressCount');
                                    if (progressCount) {
                                        progressCount.textContent = `${data.current}/${data.total}`;
                                    }
                                }
                                
                                const progressText = document.getElementById('progressText');
                                if (progressText && data.message) {
                                    progressText.textContent = data.message;
                                }
                                
                                // Update loading message
                                const loadingMessage = document.getElementById('loadingMessage');
                                if (loadingMessage) {
                                    if (data.current !== undefined && data.total !== undefined) {
                                        loadingMessage.textContent = `${data.message || 'Loading modules'} (${data.current}/${data.total})`;
                                    } else {
                                        loadingMessage.textContent = data.message || 'Loading modules...';
                                    }
                                }
                                console.log(data.message);
                            } else if (data.type === 'module') {
                                // Show table when first module arrives
                                if (moduleCount === 0) {
                        document.getElementById('loadingCard').classList.add('d-none');
                        document.getElementById('modulesCard').classList.remove('d-none');
                                }
                            
                                // Add module to collection
                                collectedModules.push(data.module);
                                allModules.push(data.module);
                                moduleCount++;
                                
                                // Sort all modules alphabetically by name
                                allModules.sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase()));
                                
                                // Rebuild table with sorted modules
                                if (tbody) {
                                    tbody.innerHTML = '';
                                    
                                    allModules.forEach(module => {
                                        const row = document.createElement('tr');
                                        row.className = 'module-row';
                                        row.setAttribute('data-category', module.category || 'Misc');
                                        
                                        const nameCell = document.createElement('td');
                                        nameCell.innerHTML = '<code>' + escapeHtml(module.name) + '</code>';
                                        
                                        const descCell = document.createElement('td');
                                        if (module.description) {
                                            descCell.innerHTML = '<small class="text-muted">' + escapeHtml(module.description) + '</small>';
                                        } else {
                                            descCell.innerHTML = '<span class="text-muted">-</span>';
                                        }
                                        
                                        const versionsCell = document.createElement('td');
                                        if (module.versions && module.versions.length > 0) {
                                            versionsCell.innerHTML = module.versions.map(v => 
                                                '<button type="button" class="btn btn-sm copy-version me-1 mb-1" data-version="' + escapeHtml(v) + '" title="Click to copy: module load ' + escapeHtml(v) + '" style="background-color: var(--theme-bg-color); border-color: var(--theme-bg-color); color: var(--theme-text-color);"><i class="fa-regular fa-copy me-1"></i><code class="text-reset">' + escapeHtml(v) + '</code></button>'
                                            ).join('');
                                        } else {
                                            versionsCell.innerHTML = '<span class="text-muted">-</span>';
                                        }
                                        
                                        row.appendChild(nameCell);
                                        row.appendChild(descCell);
                                        row.appendChild(versionsCell);
                                        tbody.appendChild(row);
                                    });
                                    
                                    // Wire up copy handlers for all buttons
                                    attachCopyHandlers();
                                }
                                
                                // Update count
                        const countEl = document.getElementById('uniqueCount');
                        if (countEl) {
                                    countEl.textContent = moduleCount;
                                }
                                
                                // Apply current filters
                                applyFilters();
                            } else if (data.type === 'descriptions_start') {
                                // Show descriptions loading alert
                                const descriptionsAlert = document.getElementById('descriptionsLoadingAlert');
                                if (descriptionsAlert) {
                                    descriptionsAlert.classList.remove('d-none');
                                }
                            } else if (data.type === 'module_update') {
                                // Update description for a specific module
                                const moduleName = data.module_name;
                                const description = data.description || '';
                                
                                // Find the row for this module and update description
                                if (tbody) {
                                    const rows = tbody.querySelectorAll('tr.module-row');
                                    rows.forEach(row => {
                                        const nameCell = row.querySelector('td:first-child code');
                                        if (nameCell && nameCell.textContent.trim() === moduleName) {
                                            const descCell = row.querySelector('td:nth-child(2)');
                                            if (descCell) {
                                                if (description) {
                                                    descCell.innerHTML = '<small class="text-muted">' + escapeHtml(description) + '</small>';
                                                } else {
                                                    descCell.innerHTML = '<span class="text-muted">-</span>';
                                                }
                                            }
                                        }
                                    });
                                }
                                
                                // Also update in allModules array
                                const moduleIndex = allModules.findIndex(m => m.name === moduleName);
                                if (moduleIndex !== -1) {
                                    allModules[moduleIndex].description = description;
                                }
                            } else if (data.type === 'descriptions_complete') {
                                // Hide descriptions loading alert
                                const descriptionsAlert = document.getElementById('descriptionsLoadingAlert');
                                if (descriptionsAlert) {
                                    descriptionsAlert.classList.add('d-none');
                                }
                            } else if (data.type === 'complete') {
                                // Refresh complete
                                eventSource.close();
                                
                                // Hide progress bar
                                const progressBarContainer = document.getElementById('progressBarContainer');
                                if (progressBarContainer) {
                                    progressBarContainer.classList.add('d-none');
                                }
                                
                                // Set progress bar to 100%
                                const progressBar = document.getElementById('progressBar');
                                if (progressBar) {
                                    progressBar.style.width = '100%';
                                    progressBar.setAttribute('aria-valuenow', 100);
                                }
                                
                                // Update category filter with all collected modules
                                const categories = new Set();
                                collectedModules.forEach(m => categories.add(m.category));
                                populateCategoryFilter(Array.from(categories).sort());
                                
                                // Update cache timestamp
                                const cacheTimestampEl = document.getElementById('cacheTimestamp');
                                const cacheTimestampValueEl = document.getElementById('cacheTimestampValue');
                                if (cacheTimestampValueEl) {
                                    const now = new Date();
                                    const formatted = now.toLocaleString('en-US', {
                                        year: 'numeric',
                                        month: '2-digit',
                                        day: '2-digit',
                                        hour: '2-digit',
                                        minute: '2-digit',
                                        second: '2-digit'
                                    });
                                    cacheTimestampValueEl.textContent = formatted;
                                }
                                if (cacheTimestampEl) {
                                    cacheTimestampEl.style.display = '';
                                }
                                
                                console.log(data.message);
                        } else if (data.type === 'error') {
                            // Error occurred
                            eventSource.close();
                            
                            // Hide progress bar
                            const progressBarContainer = document.getElementById('progressBarContainer');
                            if (progressBarContainer) {
                                progressBarContainer.classList.add('d-none');
                            }
                            
                            alert('Error: ' + data.message);
                            document.getElementById('loadingCard').classList.remove('d-none');
                            document.getElementById('modulesCard').classList.add('d-none');
                        }
                    } catch (error) {
                        console.error('Error parsing SSE data:', error);
                    }
                };
                
                eventSource.onerror = function(error) {
                    console.error('EventSource error:', error);
                    eventSource.close();
                    
                    // Hide progress bar
                    const progressBarContainer = document.getElementById('progressBarContainer');
                    if (progressBarContainer) {
                        progressBarContainer.classList.add('d-none');
                    }
                    
                    alert('Connection error while loading modules.');
                    document.getElementById('loadingCard').classList.remove('d-none');
                    document.getElementById('modulesCard').classList.add('d-none');
                };
                })
                .catch(error => {
                    console.error('Error starting module stream:', error);
                    
                    // Hide progress bar
                    const progressBarContainer = document.getElementById('progressBarContainer');
                    if (progressBarContainer) {
                        progressBarContainer.classList.add('d-none');
                    }
                    
                    alert('Failed to start loading modules. Please try again.');
                });
        }
        
        startStreamingModules();
        {% else %}
        // Modules are already cached - populate category filter
        populateCategoryFilter(categoryOrder);
        
        // Load descriptions for cached modules in background
        if (allModules.length > 0) {
            // Check if any modules are missing descriptions
            const modulesNeedingDescriptions = allModules.filter(m => !m.description || m.description.trim() === '');
            if (modulesNeedingDescriptions.length > 0) {
                // Show descriptions loading alert
                const descriptionsAlert = document.getElementById('descriptionsLoadingAlert');
                if (descriptionsAlert) {
                    descriptionsAlert.classList.remove('d-none');
                }
                
                // Start loading descriptions without clearing cache
                fetch('{{ url_for("modules.load_descriptions") }}', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to start description loading');
                    }
                    
                    // Create EventSource for streaming descriptions only
                    const eventSource = new EventSource('{{ url_for("modules.stream_descriptions") }}');
                    
                    eventSource.onmessage = function(event) {
                        try {
                            const data = JSON.parse(event.data);
                            
                            if (data.type === 'descriptions_start') {
                                // Already shown
                            } else if (data.type === 'module_update') {
                                // Update description for a specific module
                                const moduleName = data.module_name;
                                const description = data.description || '';
                                
                                // Update in allModules array
                                const moduleIndex = allModules.findIndex(m => m.name === moduleName);
                                if (moduleIndex !== -1) {
                                    allModules[moduleIndex].description = description;
                                }
                                
                                // Find the row and update description
                                const tbody = document.getElementById('modulesTableBody');
                                if (tbody) {
                                    const rows = tbody.querySelectorAll('tr.module-row');
                                    rows.forEach(row => {
                                        const nameCell = row.querySelector('td:first-child code');
                                        if (nameCell) {
                                            const cellText = nameCell.textContent.trim();
                                            if (cellText === moduleName) {
                                                const descCell = row.querySelector('td:nth-child(2)');
                                                if (descCell) {
                                                    if (description) {
                                                        descCell.innerHTML = '<small class="text-muted">' + escapeHtml(description) + '</small>';
                                                    } else {
                                                        descCell.innerHTML = '<span class="text-muted">-</span>';
                                                    }
                                                }
                                            }
                                        }
                                    });
                                }
                            } else if (data.type === 'descriptions_complete') {
                                // Hide descriptions loading alert
                                const descriptionsAlert = document.getElementById('descriptionsLoadingAlert');
                                if (descriptionsAlert) {
                                    descriptionsAlert.classList.add('d-none');
                                }
                                eventSource.close();
                            } else if (data.type === 'complete') {
                                eventSource.close();
                            }
                        } catch (error) {
                            console.error('Error parsing SSE data:', error);
                        }
                    };
                    
                    eventSource.onerror = function(error) {
                        console.error('EventSource error:', error);
                        eventSource.close();
                        const descriptionsAlert = document.getElementById('descriptionsLoadingAlert');
                        if (descriptionsAlert) {
                            descriptionsAlert.classList.add('d-none');
                        }
                    };
                })
                .catch(error => {
                    console.error('Error starting description loading:', error);
                    const descriptionsAlert = document.getElementById('descriptionsLoadingAlert');
                    if (descriptionsAlert) {
                        descriptionsAlert.classList.add('d-none');
                    }
                });
            }
        }
        {% endif %}
        
        function populateCategoryFilter(categories) {
            if (!categoryFilter || categories.length === 0) return;
            
            // Clear existing options except "All Categories"
            while (categoryFilter.options.length > 1) {
                categoryFilter.remove(1);
            }
            
            // Add category options
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                categoryFilter.appendChild(option);
            });
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function displayModules(modules) {
            const tbody = document.getElementById('modulesTableBody');
            if (!tbody) return;
            
            tbody.innerHTML = '';
            
            // Ensure modules are sorted alphabetically by name (case-insensitive)
            const sortedModules = [...modules].sort((a, b) => {
                return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
            });
            
            sortedModules.forEach(module => {
                const row = document.createElement('tr');
                row.className = 'module-row';
                row.setAttribute('data-category', module.category || 'Misc');
                
                const nameCell = document.createElement('td');
                nameCell.innerHTML = '<code>' + escapeHtml(module.name) + '</code>';
                
                const descCell = document.createElement('td');
                if (module.description) {
                    descCell.innerHTML = '<small class="text-muted">' + escapeHtml(module.description) + '</small>';
                } else {
                    descCell.innerHTML = '<span class="text-muted">-</span>';
                }
                
                const versionsCell = document.createElement('td');
                if (module.versions && module.versions.length > 0) {
                    versionsCell.innerHTML = module.versions.map(v => 
                        '<button type="button" class="btn btn-sm copy-version me-1 mb-1" data-version="' + escapeHtml(v) + '" title="Click to copy: module load ' + escapeHtml(v) + '" style="background-color: var(--theme-bg-color); border-color: var(--theme-bg-color); color: var(--theme-text-color);"><i class="fa-regular fa-copy me-1"></i><code class="text-reset">' + escapeHtml(v) + '</code></button>'
                    ).join('');
                } else {
                    versionsCell.innerHTML = '<span class="text-muted">-</span>';
                }
                
                row.appendChild(nameCell);
                row.appendChild(descCell);
                row.appendChild(versionsCell);
                tbody.appendChild(row);
            });
            
            // Apply current filters
            applyFilters();
            // Wire copy buttons
            attachCopyHandlers();
        }
        
        function applyFilters() {
            const searchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';
            const selectedCategory = categoryFilter ? categoryFilter.value : '';
            const rows = document.querySelectorAll('.module-row');
            
            if (rows.length === 0) return;
            
            // Create regex based on search term length and content
            let nameRegex = null;
            let versionRegex = null;
            if (searchTerm) {
                const escaped = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const hasNumbers = /\d/.test(searchTerm);
                
                // Versions: search if contains numbers (any length) OR if 3+ characters
                if (hasNumbers || searchTerm.length >= 3) {
                    versionRegex = new RegExp(escaped, 'i');
                }
                
                if (searchTerm.length <= 2) {
                    // 1-2 characters: must match from start of module name
                    nameRegex = new RegExp('^' + escaped, 'i');
                } else {
                    // 3+ characters: search module name with word boundary
                    if (hasNumbers) {
                        // Contains numbers - match anywhere in name
                        nameRegex = new RegExp(escaped, 'i');
                    } else {
                        // Letters only - match from word boundary
                        nameRegex = new RegExp('(^|[\\/\\-])' + escaped, 'i');
                    }
                }
            }
            
            let visibleCount = 0;
            
            rows.forEach(row => {
                // Category filter
                const rowCategory = row.getAttribute('data-category');
                const categoryMatch = !selectedCategory || rowCategory === selectedCategory;
                
                // Search filter
                let searchMatch = true;
                if (nameRegex || versionRegex) {
                    const nameCell = row.querySelector('td:nth-child(1)');
                    const descCell = row.querySelector('td:nth-child(2)');
                    const versionsCell = row.querySelector('td:nth-child(3)');
                    
                    let nameMatch = false;
                    let descMatch = false;
                    let versionMatch = false;
                    
                    // Check module name
                    if (nameRegex && nameCell) {
                        const moduleName = nameCell.textContent.trim().toLowerCase();
                        nameMatch = nameRegex.test(moduleName);
                    }
                    
                    // Check description
                    if (nameRegex && descCell) {
                        const descText = descCell.textContent.trim().toLowerCase();
                        descMatch = nameRegex.test(descText);
                    }
                    
                    // Check versions (if search contains numbers or is 3+ characters)
                    if (versionRegex && versionsCell) {
                        const versionsText = versionsCell.textContent.toLowerCase();
                        versionMatch = versionRegex.test(versionsText);
                    }
                    
                    // Match if name, description, or version matches
                    searchMatch = nameMatch || descMatch || versionMatch;
                }
                
                // Show row if both filters match
                if (categoryMatch && searchMatch) {
                    row.style.display = '';
                    visibleCount++;
                } else {
                    row.style.display = 'none';
                }
            });
            
            // Update count (show filtered count if filtering, otherwise total)
            const countElement = document.getElementById('uniqueCount');
            if (countElement) {
                if (selectedCategory || searchTerm) {
                    countElement.textContent = visibleCount;
                } else {
                    countElement.textContent = allModules.length || rows.length;
                }
            }
        }
        
        // Search functionality with debouncing (300ms delay)
        if (searchInput) {
            const debouncedApplyFilters = debounce(applyFilters, 300);
            searchInput.addEventListener('input', function() {
                // Apply immediately for 1-2 character searches, debounce for longer
                if (this.value.length <= 2) {
                    applyFilters();
                } else {
                    debouncedApplyFilters();
                }
            });
        }
        
        // Category filter functionality
        if (categoryFilter) {
            categoryFilter.addEventListener('change', applyFilters);
        }
        function copyText(text) {
            if (navigator.clipboard && navigator.clipboard.writeText) {
                return navigator.clipboard.writeText(text);
            }
            return Promise.reject(new Error('Clipboard API not available'));
        }

        function attachCopyHandlers() {
            const buttons = document.querySelectorAll('.copy-version');
            buttons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const version = btn.getAttribute('data-version');
                    if (!version) return;
                    const originalHtml = btn.innerHTML;
                    copyText(`module load ${version}`)
                        .then(() => {
                            btn.classList.add('btn-success', 'text-white');
                            btn.style.backgroundColor = '';
                            btn.style.borderColor = '';
                            btn.style.color = '';
                            btn.innerHTML = '<i class="fa-regular fa-copy me-1"></i>Copied!';
                            setTimeout(() => {
                                btn.classList.remove('btn-success', 'text-white');
                                btn.style.backgroundColor = 'var(--theme-bg-color)';
                                btn.style.borderColor = 'var(--theme-bg-color)';
                                btn.style.color = 'var(--theme-text-color)';
                                btn.innerHTML = originalHtml;
                            }, 1200);
                        })
                        .catch(err => {
                            console.error('Copy failed', err);
                        });
                });
            });
        }

        // Initial wiring for server-rendered modules
        attachCopyHandlers();
        
        // Refresh button handler with streaming
        const refreshBtn = document.getElementById('refreshModulesBtn');
        if (refreshBtn) {
            refreshBtn.addEventListener('click', function() {
                const icon = this.querySelector('i');
                const originalClass = icon.className;
                const buttonText = this.querySelector('span');
                
                // Check if already refreshing
                if (this.disabled) {
                    return;
                }
                
                // Show loading state
                icon.className = 'fas fa-spinner fa-spin me-1';
                this.disabled = true;
                
                // Clear existing modules
                allModules = [];
                const tbody = document.getElementById('modulesTableBody');
                if (tbody) {
                    tbody.innerHTML = '';
                }
                const countEl = document.getElementById('uniqueCount');
                if (countEl) {
                    countEl.textContent = '0';
                }
                
                // Show progress bar
                const progressBarContainer = document.getElementById('progressBarContainer');
                if (progressBarContainer) {
                    progressBarContainer.classList.remove('d-none');
                }
                const progressBar = document.getElementById('progressBar');
                if (progressBar) {
                    progressBar.style.width = '0%';
                    progressBar.setAttribute('aria-valuenow', 0);
                }
                
                // Start refresh process
                fetch('{{ url_for("modules.refresh_start") }}', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to start refresh');
                    }
                    
                    // Create EventSource for streaming (GET endpoint)
                    const eventSource = new EventSource('{{ url_for("modules.refresh_modules") }}');
                    
                    let moduleCount = 0;
                    const collectedModules = [];
                    
                    eventSource.onmessage = function(event) {
                        try {
                            const data = JSON.parse(event.data);
                            
                            if (data.type === 'progress') {
                                // Update progress bar
                                if (data.total && data.current !== undefined) {
                                    const percentage = Math.round((data.current / data.total) * 100);
                                    const progressBar = document.getElementById('progressBar');
                                    if (progressBar) {
                                        progressBar.style.width = percentage + '%';
                                        progressBar.setAttribute('aria-valuenow', percentage);
                                    }
                                    const progressCount = document.getElementById('progressCount');
                                    if (progressCount) {
                                        progressCount.textContent = `${data.current}/${data.total}`;
                                    }
                                }
                                
                                const progressText = document.getElementById('progressText');
                                if (progressText && data.message) {
                                    progressText.textContent = data.message;
                                }
                                
                                // Update button text with progress
                                if (buttonText) {
                                    buttonText.textContent = `${data.current || 0}/${data.total || 0}`;
                                }
                                console.log(data.message);
                            } else if (data.type === 'module') {
                                // Add module to collection
                                collectedModules.push(data.module);
                                allModules.push(data.module);
                                moduleCount++;
                                
                                // Sort all modules alphabetically by name
                                allModules.sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase()));
                                
                                // Rebuild table with sorted modules
                                if (tbody) {
                                    tbody.innerHTML = '';
                                    
                                    allModules.forEach(module => {
                                        const row = document.createElement('tr');
                                        row.className = 'module-row';
                                        row.setAttribute('data-category', module.category || 'Misc');
                                        
                                        const nameCell = document.createElement('td');
                                        nameCell.innerHTML = '<code>' + escapeHtml(module.name) + '</code>';
                                        
                                        const descCell = document.createElement('td');
                                        if (module.description) {
                                            descCell.innerHTML = '<small class="text-muted">' + escapeHtml(module.description) + '</small>';
                                        } else {
                                            descCell.innerHTML = '<span class="text-muted">-</span>';
                                        }
                                        
                                        const versionsCell = document.createElement('td');
                                        if (module.versions && module.versions.length > 0) {
                                            versionsCell.innerHTML = module.versions.map(v => 
                                                '<button type="button" class="btn btn-sm copy-version me-1 mb-1" data-version="' + escapeHtml(v) + '" title="Click to copy: module load ' + escapeHtml(v) + '" style="background-color: var(--theme-bg-color); border-color: var(--theme-bg-color); color: var(--theme-text-color);"><i class="fa-regular fa-copy me-1"></i><code class="text-reset">' + escapeHtml(v) + '</code></button>'
                                            ).join('');
                                        } else {
                                            versionsCell.innerHTML = '<span class="text-muted">-</span>';
                                        }
                                        
                                        row.appendChild(nameCell);
                                        row.appendChild(descCell);
                                        row.appendChild(versionsCell);
                                        tbody.appendChild(row);
                                    });
                                    
                                    // Wire up copy handlers for all buttons
                                    attachCopyHandlers();
                                }
                                
                                // Update count
                                if (countEl) {
                                    countEl.textContent = moduleCount;
                                }
                                
                                // Apply current filters
                                applyFilters();
                            } else if (data.type === 'descriptions_start') {
                                // Show descriptions loading alert
                                const descriptionsAlert = document.getElementById('descriptionsLoadingAlert');
                                if (descriptionsAlert) {
                                    descriptionsAlert.classList.remove('d-none');
                                }
                            } else if (data.type === 'module_update') {
                                // Update description for a specific module
                                const moduleName = data.module_name;
                                const description = data.description || '';
                                
                                // Find the row for this module and update description
                                if (tbody) {
                                    const rows = tbody.querySelectorAll('tr.module-row');
                                    rows.forEach(row => {
                                        const nameCell = row.querySelector('td:first-child code');
                                        if (nameCell && nameCell.textContent.trim() === moduleName) {
                                            const descCell = row.querySelector('td:nth-child(2)');
                                            if (descCell) {
                                                if (description) {
                                                    descCell.innerHTML = '<small class="text-muted">' + escapeHtml(description) + '</small>';
                                                } else {
                                                    descCell.innerHTML = '<span class="text-muted">-</span>';
                                                }
                                            }
                                        }
                                    });
                                }
                                
                                // Also update in allModules array
                                const moduleIndex = allModules.findIndex(m => m.name === moduleName);
                                if (moduleIndex !== -1) {
                                    allModules[moduleIndex].description = description;
                                }
                            } else if (data.type === 'descriptions_complete') {
                                // Hide descriptions loading alert
                                const descriptionsAlert = document.getElementById('descriptionsLoadingAlert');
                                if (descriptionsAlert) {
                                    descriptionsAlert.classList.add('d-none');
                                }
                            } else if (data.type === 'complete') {
                                // Refresh complete
                                eventSource.close();
                                
                                // Hide progress bar after a brief delay
                                setTimeout(() => {
                                    const progressBarContainer = document.getElementById('progressBarContainer');
                                    if (progressBarContainer) {
                                        progressBarContainer.classList.add('d-none');
                                    }
                                }, 500);
                                
                                // Set progress bar to 100%
                                const progressBar = document.getElementById('progressBar');
                                if (progressBar) {
                                    progressBar.style.width = '100%';
                                    progressBar.setAttribute('aria-valuenow', 100);
                                }
                                
                                // Update category filter with all collected modules
                                const categories = new Set();
                                collectedModules.forEach(m => categories.add(m.category));
                                populateCategoryFilter(Array.from(categories).sort());
                                
                                // Update cache timestamp
                                const cacheTimestampEl = document.getElementById('cacheTimestamp');
                                const cacheTimestampValueEl = document.getElementById('cacheTimestampValue');
                                if (cacheTimestampValueEl) {
                                    const now = new Date();
                                    const formatted = now.toLocaleString('en-US', {
                                        year: 'numeric',
                                        month: '2-digit',
                                        day: '2-digit',
                                        hour: '2-digit',
                                        minute: '2-digit',
                                        second: '2-digit'
                                    });
                                    cacheTimestampValueEl.textContent = formatted;
                                }
                                if (cacheTimestampEl) {
                                    cacheTimestampEl.style.display = '';
                                }
                                
                                // Restore button state
                                icon.className = originalClass;
                                if (buttonText) {
                                    buttonText.textContent = 'Refresh';
                                }
                                this.disabled = false;
                                
                                console.log(data.message);
                            } else if (data.type === 'error') {
                                // Error occurred
                                eventSource.close();
                                alert('Error: ' + data.message);
                                icon.className = originalClass;
                                if (buttonText.textContent !== undefined) {
                                    buttonText.textContent = 'Refresh';
                                }
                                this.disabled = false;
                            }
                        } catch (error) {
                            console.error('Error parsing SSE data:', error);
                        }
                    };
                    
                    eventSource.onerror = function(error) {
                        console.error('EventSource error:', error);
                        eventSource.close();
                        alert('Connection error while refreshing modules.');
                        icon.className = originalClass;
                        if (buttonText.textContent !== undefined) {
                            buttonText.textContent = 'Refresh';
                        }
                        this.disabled = false;
                    };
                })
                .catch(error => {
                    console.error('Error starting refresh:', error);
                    alert('Failed to start refresh. Please try again.');
                    icon.className = originalClass;
                    if (buttonText.textContent !== undefined) {
                        buttonText.textContent = 'Refresh';
                    }
                    this.disabled = false;
                });
                
                // Remove the old eventSource code that was here
            });
        }
        
        // Watch for description preloading completion (startup background task)
        let lastFileMtime = null;
        let descriptionsWatchInterval = null;
        let descriptionsUpdateInterval = null;
        
        function updateDescriptionsOnPage() {
            // Fetch updated descriptions and update the page
            fetch('{{ url_for("modules.descriptions_update") }}')
                .then(response => response.json())
                .then(data => {
                    if (data.descriptions && Object.keys(data.descriptions).length > 0) {
                        let updatedCount = 0;
                        const tbody = document.getElementById('modulesTableBody');
                        
                        // Update descriptions in allModules array
                        Object.keys(data.descriptions).forEach(baseName => {
                            const description = data.descriptions[baseName];
                            const moduleIndex = allModules.findIndex(m => m.name === baseName);
                            if (moduleIndex !== -1 && (!allModules[moduleIndex].description || allModules[moduleIndex].description.trim() === '')) {
                                allModules[moduleIndex].description = description;
                                updatedCount++;
                            }
                        });
                        
                        // Update the table if we have updates
                        if (updatedCount > 0 && tbody) {
                            const rows = tbody.querySelectorAll('tr.module-row');
                            rows.forEach(row => {
                                const nameCell = row.querySelector('td:first-child code');
                                if (nameCell) {
                                    const moduleName = nameCell.textContent.trim();
                                    if (data.descriptions[moduleName]) {
                                        const descCell = row.querySelector('td:nth-child(2)');
                                        if (descCell) {
                                            const description = data.descriptions[moduleName];
                                            if (description && description.trim()) {
                                                descCell.innerHTML = '<small class="text-muted">' + escapeHtml(description) + '</small>';
                                            }
                                        }
                                    }
                                }
                            });
                            
                            // Show loading alert if descriptions are still being loaded
                            const modulesNeedingDescriptions = allModules.filter(m => !m.description || m.description.trim() === '');
                            const descriptionsAlert = document.getElementById('descriptionsLoadingAlert');
                            if (descriptionsAlert) {
                                if (modulesNeedingDescriptions.length > 0) {
                                    descriptionsAlert.classList.remove('d-none');
                                    document.getElementById('descriptionsLoadingText').textContent = 
                                        `Loading descriptions... (${modulesNeedingDescriptions.length} remaining)`;
                                } else {
                                    descriptionsAlert.classList.add('d-none');
                                    // Show completion alert
                                    const completeAlert = document.getElementById('descriptionsCompleteAlert');
                                    if (completeAlert) {
                                        completeAlert.classList.remove('d-none');
                                    }
                                    // Stop updating
                                    if (descriptionsUpdateInterval) {
                                        clearInterval(descriptionsUpdateInterval);
                                        descriptionsUpdateInterval = null;
                                    }
                                }
                            }
                        }
                    }
                })
                .catch(error => {
                    console.debug('Error updating descriptions:', error);
                });
        }
        
        function checkDescriptionsStatus() {
            fetch('{{ url_for("modules.descriptions_status") }}')
                .then(response => response.json())
                .then(data => {
                    if (data.file_exists && data.file_mtime) {
                        // First time seeing the file - record the mtime
                        if (lastFileMtime === null) {
                            lastFileMtime = data.file_mtime;
                            // Check if we have modules without descriptions
                            const modulesNeedingDescriptions = allModules.filter(m => !m.description || m.description.trim() === '');
                            if (modulesNeedingDescriptions.length > 0) {
                                const descriptionsAlert = document.getElementById('descriptionsLoadingAlert');
                                if (descriptionsAlert) {
                                    descriptionsAlert.classList.remove('d-none');
                                    document.getElementById('descriptionsLoadingText').textContent = 'Loading descriptions in background...';
                                }
                                // Start updating descriptions on page
                                updateDescriptionsOnPage();
                                descriptionsUpdateInterval = setInterval(updateDescriptionsOnPage, 3000);
                            }
                        } else if (data.file_mtime > lastFileMtime) {
                            // File was updated - update last mtime
                            lastFileMtime = data.file_mtime;
                            // Update descriptions on page immediately
                            updateDescriptionsOnPage();
                        }
                    }
                })
                .catch(error => {
                    console.debug('Error checking descriptions status:', error);
                });
        }
        
        // Start watching for description preloading (check every 5 seconds)
        // Only watch if we have modules that might need descriptions
        if (allModules.length > 0) {
            const modulesNeedingDescriptions = allModules.filter(m => !m.description || m.description.trim() === '');
            if (modulesNeedingDescriptions.length > 0) {
                // Initial check
                checkDescriptionsStatus();
                // Then check every 5 seconds for file updates
                descriptionsWatchInterval = setInterval(checkDescriptionsStatus, 5000);
                // Also start updating descriptions on page every 3 seconds
                updateDescriptionsOnPage();
                descriptionsUpdateInterval = setInterval(updateDescriptionsOnPage, 3000);
            }
        }
    });
})();
</script>
{% endblock %}
